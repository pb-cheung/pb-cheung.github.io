(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{530:function(t,e,a){"use strict";a.r(e);var r=a(56),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"浏览器并发请求限制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器并发请求限制"}},[t._v("#")]),t._v(" 浏览器并发请求限制")]),t._v(" "),a("h2",{attrs:{id:"机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#机制"}},[t._v("#")]),t._v(" 机制")]),t._v(" "),a("blockquote",[a("p",[t._v("在浏览器中，存在一个并发连接池（connection pool），用于维护与服务器之间的连接。这个连接池允许浏览器同时建立多个与同一域名下的服务器的连接，以便并行发送请求并同时接收响应。\n当浏览器发起请求时，它会检查当前与目标域名的连接数。如果当前的连接数还未达到浏览器的限制值，浏览器会立即建立一个新的连接并发送请求。这样，多个请求可以在同一时刻并发地进行。\n然而，当达到并发连接数限制时，浏览器会将其他的请求放入一个请求队列中，等待当前连接的请求完成后再发送。这种机制确保了浏览器不会过度占用网络资源，保持了网络的平衡和稳定性。")])]),t._v(" "),a("p",[t._v("这种机制旨在提高页面加载性能和网络资源的利用率。")]),t._v(" "),a("h2",{attrs:{id:"限制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#限制"}},[t._v("#")]),t._v(" 限制")]),t._v(" "),a("p",[t._v("一般是6个（Chrome）")]),t._v(" "),a("p",[t._v("基于端口数量和线程切换开销的考虑，浏览器不可能无限量的并发请求，所以要有限制。也因此衍生除了HTTP1.1的Keep Alive")])])}),[],!1,null,null,null);e.default=s.exports}}]);